# Generated by Grok

from z3 import *


def optimize_index_selection(indexes, queries, candidate_indexes, costs, storage_costs, budget):
    """
    Optimize index selection to minimize query execution costs under a storage budget using Z3.
    
    Parameters:
    - indexes: List of index identifiers
    - queries: List of query identifiers
    - candidate_indexes: Dict mapping each query to its list of candidate indexes
    - costs: Dict mapping each query to a tuple (cost_with_index, cost_without_index)
    - storage_costs: Dict mapping each index to its storage cost
    - budget: Maximum allowed total storage cost
    
    Returns:
    - Tuple (selected_indexes, total_cost) or (None, None) if no solution exists
    """
    # Create an optimization solver
    opt = Optimize()
    
    # Define boolean variables for each index (True if selected, False otherwise)
    x = {idx: Bool(f"x_{idx}") for idx in indexes}
    
    # Add storage constraint: total storage cost of selected indexes <= budget
    storage = Sum([If(x[idx], storage_costs[idx], 0) for idx in indexes])
    opt.add(storage <= budget)
    
    # Compute query costs based on selected indexes
    query_costs = []
    for q in queries:
        # Check if at least one candidate index is selected for this query
        candidates = candidate_indexes[q]
        has_index = Or([x[idx] for idx in candidates])
        cost_if_index, cost_if_no_index = costs[q]
        # Cost is lower if an index is available, higher otherwise
        query_cost = If(has_index, cost_if_index, cost_if_no_index)
        query_costs.append(query_cost)
    
    # Define the objective: minimize the total query execution cost
    total_cost = Sum(query_costs)
    opt.minimize(total_cost)
    
    # Solve the optimization problem
    if opt.check() == sat:
        model = opt.model()
        selected_indexes = [idx for idx in indexes if model[x[idx]]]
        total_cost_value = model.eval(total_cost)
        return selected_indexes, total_cost_value
    else:
        return None, None

# Example usage with a complex scenario
if __name__ == "__main__":
    # Define the problem data
    indexes = ['i1', 'i2', 'i3', 'i4']
    queries = ['q1', 'q2', 'q3', 'q4']
    
    # Each query has a set of candidate indexes that can reduce its cost
    candidate_indexes = {
        'q1': ['i1', 'i2'],      # q1 can use i1 or i2
        'q2': ['i2', 'i3'],      # q2 can use i2 or i3
        'q3': ['i3', 'i4'],      # q3 can use i3 or i4
        'q4': ['i1', 'i4']       # q4 can use i1 or i4
    }
    
    # Costs: (cost_with_index, cost_without_index)
    costs = {
        'q1': (10, 100),    # q1: 10 if indexed, 100 if not
        'q2': (20, 200),    # q2: 20 if indexed, 200 if not
        'q3': (30, 300),    # q3: 30 if indexed, 300 if not
        'q4': (40, 400)     # q4: 40 if indexed, 400 if not
    }
    
    # Storage cost for each index
    storage_costs = {
        'i1': 5,    # i1 takes 5 units
        'i2': 3,    # i2 takes 3 units
        'i3': 4,    # i3 takes 4 units
        'i4': 2     # i4 takes 2 units
    }
    
    budget = 10  # Total storage budget
    
    # Run the optimization
    selected, total_cost = optimize_index_selection(
        indexes, queries, candidate_indexes, costs, storage_costs, budget
    )
    
    if selected is not None:
        print(f"Selected indexes: {selected}")
        print(f"Total query execution cost: {total_cost}")
        print(f"Total storage used: {sum(storage_costs[idx] for idx in selected)}")
    else:
        print("No feasible solution found within the storage budget.")